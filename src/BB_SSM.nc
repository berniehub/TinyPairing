/**
 *
 * This file provides implementation for BLS Short Signature
 * The version is the general version, in the way that all random numbers are represented and operated as large integers.
 * Conversions from and to trinary representation are needed.
 *
 *
 * Author: Xiaokang Xiong (xkxiong@gmail.com)
 * Date: Jul, 2009
 */

#include "crypto.h"

module BB_SSM{
    
    provides interface BB_SS;
    uses interface BaseField;
    uses interface ExtField2;
    uses interface PointArith;
    uses interface Pairing;
    uses interface GetRandom;
    uses interface NN;
}

implementation{
    
    /*
     * Key generation
     * Input a point as generator
     * Output private key sk, and public key pk.
     * Privakte key is generated by convert a random binary string to a trinary element
     */
    command void BB_SS.keygen(Point* g1, Point* g2, Point* u, Point* v, ExtElement2* z, BigInt x, BigInt y){
        
        call GetRandom.generator(g1);
        call GetRandom.generator(g2);
        call GetRandom.bigint(x);
        call GetRandom.bigint(y);
        
        //public keys
        call PointArith.mult_proj2(x, g2, u);
        call PointArith.mult_proj2(y, g2, v);
        call Pairing.pairing(g1, g2, z);
        
    }
    
    /*
     * signing a message msg of length len with a given secret key sk
     * Output the signature sig
     * return true if success, false if not
     */
    command bool BB_SS.sign(BigInt msg, Point* g1, BigInt x, BigInt y, BigInt r, CpElement sig){
        BigInt sum,t;
        Point psig;
	  	
        call GetRandom.bigint(r);
        
        //sum=x+m+yr
        call NN.ModMult(sum, y, r, GORDER, BIGINT_LEN);
        call NN.Mod(t, x, BIGINT_LEN, GORDER, BIGINT_LEN);
        call NN.Add(sum, t, sum, BIGINT_LEN);
        call NN.Mod(t, msg, BIGINT_LEN, GORDER, BIGINT_LEN);
        call NN.Add(sum, t, sum, BIGINT_LEN);
        
        //modula inverse
        call NN.ModInv(sum, sum, GORDER, BIGINT_LEN);
		
        call PointArith.mult_proj2(sum, g1, &psig);
        
        //compress signature point, including both x and y coordinates
        call PointArith.cps(&psig, sig);
        
        return TRUE;
    }
    
    /*
     * signature verification
     * return 1 signature verified
     * return 0, signature verificatin failed
     * return -1, invalid signature
     */
    command int8_t BB_SS.verify(Point* g1, Point* g2, Point* u, Point* v, ExtElement2* z, BigInt msg, BigInt r, CpElement sig){
        Point p1,p2;
        ExtElement2 E;
        
        
        call PointArith.mult_proj2(msg, g2, &p1);
        call PointArith.mult_proj2(r, v, &p2);
        call PointArith.add(u, &p1, &p1);
        call PointArith.add(&p1, &p2, &p2);
        
        if(!call PointArith.dcps(sig, &p1)) return -1;
        
        //pairing
        call Pairing.pairing(&p1, &p2, &E);
        
        
        if(memcmp(&E, z, ELEMENT_LEN*6)==0)	
            return 1;
        else
            return 0;
    }
    
} 
