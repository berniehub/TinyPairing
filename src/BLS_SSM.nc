/**
 *
 * This file provides implementation for BLS Short Signature
 * The version is the general version, in the way that all random numbers are represented and operated as large integers.
 * Conversions from and to trinary representation are needed.
 *
 *
 * Author: Xiaokang Xiong (xkxiong@gmail.com)
 * Date: Jul, 2009
 */

#include "crypto.h"

module BLS_SSM{
    
    provides interface BLS_SS;
    uses interface BaseField;
    uses interface ExtField2;
    uses interface PointArith;
    uses interface Pairing;
    uses interface GetRandom;
}

implementation{
    
    /*
     * Key generation
     * Input a point as generator
     * Output private key sk, and public key pk.
     * Privakte key is generated by convert a random binary string to a trinary element
     */
    command void BLS_SS.keygen(Point* generator, Point* pk, BigInt sk){
        
        call GetRandom.generator(generator);
        call GetRandom.bigint(sk);
        
        //public key pk
        call PointArith.mult_proj2(sk, generator, pk);
    }
    
    /*
     * signing a message msg of length len with a given secret key sk
     * Output the signature sig
     * return true if success, false if not
     */
    command bool BLS_SS.sign(UInt* msg, uint32_t len, BigInt sk, CpElement sig){
        Point pmsg;
        
        if(!(call PointArith.map2point(msg, len, &pmsg))) return FALSE;
        
        call PointArith.mult_proj2(sk, &pmsg, &pmsg);
        
        //compress signature point, only the x coordinate
        call BaseField.cps(&pmsg.x, sig);
        
        /*
         //compress signature point, including both x and y coordinates
         call PointArith.cps(&pmsg, sig);
         */
        
        return TRUE;
    }
    
    /*
     * signature verification
     * return 1 or 2 signature verified
     * return 0, signature verificatin failed
     * return -1, invalid signature
     * return -2, invalid message
     */
    command int8_t BLS_SS.verify(Point* generator, Point* pk, UInt* msg, uint32_t len, CpElement sig){
        Point pmsg, psig;
        ExtElement2 E1, E2;
        
        call BaseField.dcps(sig, &psig.x);
        if(!(call PointArith.get_y(&psig.x, &psig.y))) return -1;
        if(!(call PointArith.map2point(msg, len, &pmsg))) return -2;
        
        //pairing
        call Pairing.pairing(generator, &psig, &E1);
        call Pairing.pairing(pk, &pmsg, &E2);
        
        if(memcmp(&E1, &E2, ELEMENT_LEN*6)==0)
            return 1;
        else{
            call ExtField2.mult(&E1, &E2, &E1);
            memset(&E2, 0x0, ELEMENT_LEN*6);
            E2.ext[0].mid[0] = ELEMENT_ONE;
            if(memcmp(&E1, &E2, ELEMENT_LEN*6)==0)
                return 2;
            else return 0;
        }
    }
}
